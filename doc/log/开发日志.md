#### 2020.7.2.10.03 mjh

* 增加了开发日志，说实话我也不知道该怎么写，不过先这样用一个四级标题加分点叙述吧
* 增加TIterator和UIterator两个类，分别用于题目分析和用户分析，可以通过调用iterator.py里面的方法得到对象，个人认为应该很好用
* 因为题目分析和用户分析我们都先涉及到了，所以在写代码的时候要区分开现在的研究对象是以用户为导向还是以题目为导向，必要时通过T（topic）和U（user）来区分，可以参开第二点



#### 2020.7.2.14.49 mjh

* effective_answer_checker，检测有效代码。已经可以排除非Python语言的代码



#### 2020.7.2 15.43 mjh

* 现在可以排除大量使用if和elif实现面向用例的代码



#### 2020.7.3 10.00 mjh

* 更新了查找大量if-else代码的标准，找到更多更准确的面向用例的代码
* 增加了file_operations.py文件，在其中可以找到和阅读文件、阅读json文件、生成json文件、通过迭代器添加字典元素的方法
* 将iterator的重复代码替换为新写的方法
* 将iterator中生成迭代文件的方法放到iterator_builder.py文件中，确立标准function文件夹里的内容是辅助类和辅助方法，analysis文件夹里的内容是可以针对数据运行的文件
* 由于file_checker是面向数据操作的，所以将该文件转移到analysis文件夹中
* 新增invalid_filter，目的是删除无效代码数据
* source文件夹下面新建无效代码文件夹，无效代码文件夹下新建用户分析和题目分析文件夹，保存没用的代码，先留着吧，以后可能有用



#### 2020.7.5 06.23 hz

* 添加reference日志，用以记录参考过的资料、博客等



#### 2020.7.6 09.30 mjh

* 连麦写代码



#### 2020.7.6 10.09 hz

* 更新了对所有用例题目难度对评价代码，生成题目的难度系数
* 增加了/src/analysis/rank_the_exercises.py文件，他进行对题目难度的评估，并生成结果文件/data/analysis/difficulty_of_exercises.json



#### 2020.7.6 15.21 mjh

* 写了一个user_scores.py可以对分数分析的文件
* 有一个问题是这样的，我们采用的样本并不是用户最后一次提交的代码，而是他们在提交过程中最高分的代码。如果想要改动的话难度可能太大了，所以暂时先这样处理吧
* 修改了iterator_builder.py文件，解决一个保留了空文件夹的bug。需要重新运行一下这个文件
* 实现通过user_id获得八边形战士的方法



#### 2020.7.7. 07.46 mjh

* 把前期方法正好到预处理文件当中，然后写了个主要的运行文件main.py
* 改名wzx的文件名为code_name，这样以后各自代码以user、topic、code开头，比较清晰



#### 2020.7.7.10.24 mjh

* 写了一个user_evaluation的类，用来评判用户的水准



#### 2020.7.9 11.10 mjh

* 现在已经做出了用户的综合排名，其中第一第二有抄袭的嫌疑



#### 2020.7.12 08.16 wzx

> ### 参考网站
>
> * <a href="https://www.jianshu.com/p/36e686decad2" target="_blank">python代码规范和命名规范</a>
>
> ### 命名标准
>
>  #### 模块 
>
> 模块尽量使用小写命名，首字母保持小写，尽量不要用下划线(除非多个单词，且数量不多的情况)
>
>  #### 类名
>
>  类名使用驼峰(CamelCase)命名风格，首字母大写，私有类可用一个下划线开头
>
>  #### 函数
>
>  函数名一律小写，如有多个单词，用下划线隔开  
>  私有函数在函数前加一个下划线_
>
>  #### 变量名
>
>  变量名尽量小写, 如有多个单词，用下划线隔开  
>  常量采用全大写，如有多个单词，使用下划线隔开
>
>  #### 常量
>
>  常量使用以下划线分隔的大写命名
>
>  ### 评分标准
>
>  按照标准命名占全部命名的比例来评估该生命名规范的得分   
>  例如：整个代码共有五处命名，该生四处命名规范，得分为八十。   
>  但我们的计算是要计算该生的所有代码，因此我们可以有一个较为庞大的基数作为数据  
>  如果可以更精确的话，我们可以将学生的代码命名分为五个部分（模块、类名、函数、变量名、常量）进行分别计算
>  并制作出雷达图。



#### 2020.7.14 00.37 hz

* 重新调整题目评估，三个角度：难度、量、effort；对应三个json文件
* 实际上图结构的平均代码量还要比树结构大，认为"图结构代码简单题目难"可以忽略



#### 2020.7.18 23.19 wzx

* 初步写完代码评价
* 根据log中的命名标准对每个学生在命名方面的规范程度进行打分 



#### 2020.7.19 16.42 hz

* 重新调整题目评估，从同学的答案开搞
* 上次的观点抛弃，问题解决
* 生成的文件只一个，是代码平均难度的结果



#### 2020.7.20 10.05 mjh

* 规范化代码



#### 2020.7.20 10.18 hz

* 调整由面向用例的代码造成的偏差的题目难度所占比例



#### 2020.7.20 10.50 mjh

* 代码 （忽略导入等）
  * 变量
    * 是否为合法单词
  * 对变量的操作
    * 分类
      * 方法 advanced 2
      * 类 advanced 3
      * 结构化代码 2
      * 操作符 normal 1
      * 库方法 normal 1
    * 评判：
      * advance / normal
  * 整体代码长度
  
  
  
#### 2020.7.20 14.47 hz

* 将题目难度的原始数据分布到0～1之间
* 实现题目难度排序，绘制按照题目难度排序的柱形图，生成按照难度排序的json文件



#### 2020.7.20 22.40 hz

* 题目难度图保存（mjh添加的一行，hz推）
* 图中改为每类题一种颜色的条带，容易看出不同类题目的整体难度分布